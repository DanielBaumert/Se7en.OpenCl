using Se7en.OpenCl.Native;
using System;

namespace Se7en.OpenCl
{
    public unsafe class Programm : Handle
    {
        private uint _referenceCount;
        /// <summary>
        /// Return the program reference count.
        /// </summary>
        public ref readonly uint ReferenceCount => ref GetOrUpdateUnmanaged<uint, ProgramInfo, uint>(ref _referenceCount, ProgramInfo.ReferenceCount, NativeCl.GetPlatformInfo);

        private Context _context;
        /// <summary>
        /// Return the context specified when the program object is created
        /// </summary>
        public ref readonly Context Context => ref GetOrUpdateHandle<Context, ProgramInfo, uint>(ref _context, ProgramInfo.Context, NativeCl.GetPlatformInfo);

        private uint _numDevices;
        /// <summary>
        /// Return the number of devices associated with program.
        /// </summary>
        public ref readonly uint NumDevices => ref GetOrUpdateUnmanaged<uint, ProgramInfo, uint>(ref _numDevices, ProgramInfo.NumDevices, NativeCl.GetPlatformInfo);

        private Device[] _devices;
        /// <summary>
        /// Return the list of devices associated with the program object. This can be the devices associated with context on which the program object has been created or can be a subset of devices that are specified when a program object is created using clCreateProgramWithBinary.
        /// </summary>
        public ref readonly Device[] Devices => ref GetOrUpdateHandles<Device, ProgramInfo, uint>(ref _devices, ref _numDevices, ProgramInfo.Devices, NativeCl.GetPlatformInfo);

        private string _source;
        /// <summary>
        /// Return the program source code specified by clCreateProgramWithSource. The source string returned is a concatenation of all source strings specified to clCreateProgramWithSource with a null terminator. The concatenation strips any nulls in the original source strings.<para/>
        /// If program is created using clCreateProgramWithBinary, clCreateProgramWithIL or clCreateProgramWithBuiltInKernels, a null string or the appropriate program source code is returned depending on whether or not the program source code is stored in the binary.<para/>
        /// The actual number of characters that represents the program source code including the null terminator is returned in param_value_size_ret.
        /// </summary>
        public ref readonly string Source => ref GetOrUpdateString<ProgramInfo, uint>(ref _source, ProgramInfo.Source, NativeCl.GetProgramInfo);

        private string _il;
        /// <summary>
        /// Returns the program IL for programs created with clCreateProgramWithIL.<para/>
        /// If program is created with clCreateProgramWithSource, clCreateProgramWithBinary or clCreateProgramWithBuiltInKernels the memory pointed to by param_value will be unchanged and param_value_size_retwill be set to 0.
        /// </summary>
        public ref readonly string IL => ref GetOrUpdateString<ProgramInfo, uint>(ref _il, ProgramInfo.IL, NativeCl.GetProgramInfo);

        private long[] _binarySizes;
        /// <summary>
        /// Returns an array that contains the size in bytes of the program binary (could be an executable binary, compiled binary or library binary) for each device associated with program. The size of the array is the number of devices associated with program. If a binary is not available for a device(s), a size of zero is returned.<para/>
        /// If program is created using clCreateProgramWithBuiltInKernels, the implementation may return zero in any entries of the returned array.
        /// </summary>
        public ref readonly long[] BinarySizes => ref GetOrUpdateUnmanagedArray<long, ProgramInfo, uint>(ref _binarySizes, ProgramInfo.BinarySizes, NativeCl.GetProgramInfo);


        private byte[][] _binarys;
        /// <summary>
        /// Return the program binaries(could be an executable binary, compiled binary or library binary) for all devices associated with program.<br/>
        /// For each device in program, the binary returned can be the binary specified for the device when program is created with clCreateProgramWithBinary or it can be the executable binary generated by clBuildProgram or clLinkProgram.<br/>
        /// If program is created with clCreateProgramWithSource or clCreateProgramWithIL, the binary returned is the binary generated by clBuildProgram, clCompileProgram or clLinkProgram.<br/>
        /// The bits returned can be an implementation-specific intermediate representation(a.k.a.IR) or device specific executable bits or both.<br/>
        /// The decision on which information is returned in the binary is up to the OpenCL implementation.
        /// </summary>
        public ref readonly byte[][] Binarys
        {
            get
            {
                long[] binarySizes = BinarySizes;
                int nBinarys = binarySizes.Length;
                _binarys = new byte[binarySizes.Length][];
                ErrorCode error;
                for (int iBinary = 0; iBinary < nBinarys; iBinary++)
                {
                    ref byte[] binaryBuffer = ref _binarys[iBinary];
                    ref long size = ref binarySizes[iBinary];

                    fixed (byte* binaryBufferPtr = binaryBuffer)
                    {
                        if ((error = (ErrorCode)NativeCl.GetProgramInfo(_handle, (uint)ProgramInfo.Binaries, (IntPtr)iBinary, binaryBufferPtr, out _)) != ErrorCode.Success)
                        {
                            throw new Exception(error.ToString());
                        }
                    }
                }

                return ref _binarys;
            }
        }

        private uint _numKernels;
        /// <summary>
        /// 
        /// </summary>
        public ref readonly uint NumKernels => ref GetOrUpdateCount<ProgramInfo, uint>(ref _numKernels, ProgramInfo.NumKernels, NativeCl.GetProgramInfo);

        private string[] _kernelNames;
        /// <summary>
        /// Returns a list of kernel names in program that can be created with clCreateKernel.<br/>
        /// This information is only available after a successful program executable has been built for at least one device in the list of devices associated with program.
        /// </summary>
        public ref readonly string[] KernelNames => ref GetOrUpdateStringArray<ProgramInfo, uint>(ref _kernelNames, ref _numKernels, ';', ProgramInfo.KernelNames, NativeCl.GetProgramInfo);

        private bool _scope​Global​Ctors​Present;
        /// <summary>
        /// This indicates that the program object contains non-trivial constructor(s) that will be executed by runtime before any kernel from the program is executed.
        /// </summary>
        public ref readonly bool Scope​Global​Ctors​Present => ref GetOrUpdateUnmanaged<bool, ProgramInfo, uint>(ref _scopeGlobalCtorsPresent, ProgramInfo.ScopeGlobalCtorsPresent, NativeCl.GetProgramInfo);
        private bool _scope​Global​Dtors​Present;
        /// <summary>
        /// This indicates that the program object contains non-trivial destructor(s) that will be executed by runtime when program is destroyed.
        /// </summary>
        public ref readonly bool Scope​Global​Dtors​Present => ref GetOrUpdateUnmanaged<bool, ProgramInfo, uint>(ref _scopeGlobalDtorsPresent, ProgramInfo.ScopeGlobalDtorsPresent, NativeCl.GetProgramInfo);

        public override void Dispose()
        {
            ErrorCode error;
            if ((error = (ErrorCode)NativeCl.ReleaseProgram(_handle)) != ErrorCode.Success)
            {
                throw new Exception(error.ToString());
            }
        }

        public override void Retain()
        {
            ErrorCode error;
            if ((error = (ErrorCode)NativeCl.RetainProgram(_handle)) != ErrorCode.Success)
            {
                throw new Exception(error.ToString());
            }
        }
    }
}
